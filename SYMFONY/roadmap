                            ----------------
                                SYMFONY  
                            ----------------
LTS : Long Time Support

INTRO : Qu'est-ce que SYMFONY
ETAPE 1 : Installation de SF 3.4
ETAPE 2 : Les Bundles
ETAPE 3 : Les routes et les controllers
ETAPE 4 : Créer la boutique sur SF
ETAPE 5 : TWIG (moteur de template)
ETAPE 6 : Les assets
ETAPE 7 : Entités
ETAPE 8 : DOCTRINE
ETAPE 9 : Les formulaires
ETAPE 10 : Validation des données 
ETAPE 11 : Association Mapping
ETAPE 12 : Sécurité et Utilisateurs 
ETAPE 13 : Installation et boutique sur SF 4.3
BONUS : Mise en Prod
BONUS : Formulaire de contact 

-------------------------------------------
INTRO : Qu'est-ce que SYMFONY
-------------------------------------------

1/  Quel intérêt d'utiliser un framework

    A. Une organisation optimisée
    B. Fonctionnalités communes à tous les projets
    C. Service disponible (Routing, Sécurité, BDD, Moteur de template, Formulaire...)
    D. Communauté

2/ Choix du framework

    A. Propre Framework (pédagogie)
    B. Les framework Fullstack (Symfony, Zend, Laravel, Cake)
    C. Les minis Framework (Silex, Slim, CodeIgniter, Lumen...)

3/ Symfony

    -> Framework Français crée par Sensiolabs
    -> Versions : 
        LTS : (Long Time Support)
            v2.8
            v3.4 : 2.8 plus souple (moins rigide), avec des fonctionnalités 
            v4.4 : 3.4 BundleLess, Flex, Encore (Webpack), Maker, PHP 7.1

-------------------------------------------
ETAPE 1 : Installation de SF 3.4
-------------------------------------------
Sommaire : 
1/ Installer Composer
2/ Installer SF3.4
3/ Arborescence des dossiers et fichiers
4/ Lancement de l'application 

---------------------------------------- 

1/ Installer Composer 

Composer est un outils de dépendance. Il permet de télécharger et de mettre à jour tous les outils (services, composants, dépendances) dont on a besoin. 

    Télécharger : https://getcomposer.org/download/
    composer-setup.exe 

    -Installer : Suivre les étapes.


2/ Installer SF3.4

    - Dans le dossier Symfony
    - Maj + clic-droit : Ovrir une fenêtre powershell ici 

    <cmd>
    composer create-project symfony/framework-standard-edition test

    ==> A ce stade un dossier test a été crée. C'est un nouveau projet SF


3/ Arborescence des dossiers et fichiers

    - app/    : contient toute la configuration de l'app (BDD, sécurité, routes...)
    - bin/    : Les éxécutable de l' app (de SF)
    - src/    : Le dossier dans lequel nous allons coder notre MVC
    - var/    : Les fichiers écrits par SF au fur et à mesure (cache, logs)
    - tests/  : Les test unitaires.
    - web/    : Les repertoire WEB (app.php ou app_dev.php, img/css/js/fonts)
    - vendor/ : Le coeur de SF (les fichiers codés par les Sensio Labs)

    - composer.json : Contient la liste de toutes les dépendances dont ont a besoin 

4/ Lancement de l'application

    - Méthode 1 : 
    localhost/Back/SYMFONY/test/web/app.php
    localhost/Back/SYMFONY/test/web/app_dev.php

    - Méthode 2 :
    On va dans le dossier test/
    <cmd>
    php bin/console server:run 

    localhost:8000

    - Différences entre mode prod et dev :
    localhost/Back/SYMFONY/test/web/toto
    localhost:8000/toto



-------------------------------------------
ETAPE 2 : Les Bundles
-------------------------------------------
Sommaire : 
1/ Le concepte des Bundles
2/ Création de notre premier Bundle
-------------------------------------------


1/ Le concepte des Bundles

    - Les Bundles sont des briques de notre applications.

    UserBundle :
        UserController (C)
        UserModel (M)
        View : inscription/connexion/profil...
    
    Avec la nouvelle version de SF (4), on considère qu'il est préférable de crée un seul bundle (AppBundle).

2/ Création de notre premier Bundle

    On va créer un Bundle : POLES/TestBundle

    <cmd>
    php bin/console generate:bundle

    -> yes
    -> POLES/TestBundle
    -> POLESTestBundle
    -> src/
    -> annotation

    => Notre Bundle a été crée, mais il faut l'enregistrer.

    <code>composer.json
    "psr-4": {
            "AppBundle\\": "src/AppBundle",
            "POLES\\": "src/POLES"
        },
    
    - Mise à jour de l'app
    <cmd>
    composer update 

    ==> Notre Bundle existe dans src/POLES/TestBundle
    Il est composé de 4 dossiers :
    - Controller : les controllers du bundle 
    - DependencyInjection : Injection de dépendences
    - Ressources : Vues et Routes (YML) et eventuellement JS
    - Test : Test liés aux fonctionnalité du Bundle

    ==> A ce stade le bundle est fonctionnel, mais il y a une petite erreur qu'on va corriger;

    - src/POLES/TestBundle/Controller/DefaultController.php 

    <code>
    return $this->render('POLESTestBundle:Default:index.html.twig');
    Devient :
    return $this->render('@POLESTest/Default/index.html.twig');

    ==> A ce stade ma page d'accueil affiche "Hello world"




-------------------------------------------
ETAPE 3 : Les routes et les controllers
-------------------------------------------
Sommaire : 
1/ La création de routes
2/ L'objet Request
3/ L'objet Response
4/ Redirection 
5/ Message 

----------------------------------------

1/ La création de routes
    ("/") -> route simple homepage
    ("/bonjour/") -> route echo (erreur)
    ("/bonjour2/") -> route response
    ("/hello/{prenom}") -> route response + param URL
    ("/hola/{prenom}") -> route render de vue + param URL
    ("/hola/{prenom}") -> route render de vue + 2 params URL
    ("/ciao/{prenom}/{age}") -> route render de vue + 2 params URL
    ("redirect/") -> route avec redirection (RedirectResponse)
    ("/redirect2") -> route avec redirection (redirectToRoute())
    ("/message/") -> route avec redirect et message en session 





2/ L'objet Request
    <code>
    use Symfony\Component\HttpFoundation\Request;

    Correspond à la partie requete de la requete HttpFoundation

    <ex code>
    <code>
    $session = $request->getSession();
    -> recupère la session ($_SESSION)

    Autres exemples : 
    <code>
    $session->set('prenom', 'Yannis');
    echo $session->get('prenom');

    Autres methodes : 
    <code>
    $request->session->set('prenom', 'Yannis');

    Autres utilité de $request : 
    index.php?argument_url=toto
    <code>
    $request->query->get('argument_url');

    $request->request->get('champs_form');
    $request->cookies->get('cookie');
    $request->server->get('server');

    /exemple/{prenom}
    $prenom

    /exemple/?prenom=Yannis
    $prenom


3/ L'objet Response
    - Correspond à la partie réponse d'une requête HTTp.

    <code>
    use Symfony\Component\HttpFoundation\Response;

    Toute action (fonction) doit avoir une réponse.
    <code>
    return new Response('toto');

    même la fonction render est une réponse.

    <code>
    return $this->render();
    return $this->getTemplating()->renderResponse;


4/ Redirection

    <code>première méthode : 
    use Symfony\Component\HttpFoundation\RedirectResponse;

    cf route "/redirect/" et "/redirect2/"

    /!\ A ce stade toutes nos routes doivent avoir un name

    5/ Message 

    <code>
    $session->getFlashBag()->add();

    -> permet de d'enregistrer des messages qui seront disponible dans d'autres pages (messages de félicitations, ou d'erreur).

    -> app.session : Qui nous permet en Twig de récupérer les infos en session.

    -> app.user : Qui nous permet en Twig de récupérer les infos de l'utilisateur actuellement connecté. 



-------------------------------------------
ETAPE 4 : Créer la boutique sur SF
-------------------------------------------
Sommaire : 
1/ Creation du projet
2/ Réorganiser le AppBundle
3/ Création des premières routes 
-------------------------------------------

1/ Creation du projet

    - Dans le dossier Symfony
    <cmd>
    composer create-project symfony/framework-standard-edition Boutique3
    cd Boutique3
    php bin/console server:run

    Test : localhost:8000

2/ Réorganiser le AppBundle

    -> Création de nos controllers:
    AdminController
    MembreController
    CommandeController
    ProduitController

    -> Création de nos vues:
    Admin/ list_produit, form_produit etc...
    Membre/ connexion, inscription, profil etc...
    commande/ panier, transport, livraison, paiement etc...
    Produit/ home, categorie, boutique, fiche_produit etc...

    Localhost/                          -> Produit/index.html.twig
    localhost/categorie/pull            -> Produit/index.html.twig
    localhost/produit/12                -> Produit/show.html.twig


Admin Controller :

localhost/admin/produit/list/            -> Admin/list_produit.html.twig
        -> 'je suis dans la page qui liste les produits'

localhost/admin/produit/add/            -> Admin/form_produit.html.twig
        -> 'je suis dans le formulaire produit'

CRUD PRODUIT 

@Route("/admin/produit/", name="admin_produit")
public function adminProduitAction()
Admin/list_produit.html.twig'

@Route("/admin/produit/add/", name="admin_add_produit")
public function adminProduitAddAction()
Admin/form_produit.html.twig'

@Route("/admin/produit/update/{id}/", name="admin_produit_update")
public function adminProduitUpdateAction($id)
Admin/form_produit.html.twig'

@Route("/admin/produit/delete/{id}/", name="admin_produit_delete")
public function adminProduitDeleteAction($id, Request $request)
redirectToRoute('admin_produit');


3/ Création des premières routes

-> ProduitController : "/", "/produit/{id}/" etc...
-> AdminController : "/admin/produit/", "admin/membre/" etc...


-------------------------------------------
ETAPE 5 : TWIG (moteur de template)
-------------------------------------------
Sommaire : 
1/ Creation du layout
2/ L'héritage Twig
3/ Modification de nos vues 
4/ Documentation Twig 
-------------------------------------------

TWIG est le moteur de template de Symfony. Un moteur de template (tpl, smarty, twig, blade...) permet d'afficher du php dans les vues HTML de manière pkus simple.

    exemple : 
    <?= $membre['prenom'] ?>
    {{ membre.prenom }}



1/ Creation du layout

    Chemin : Boutique3/app/Resources/views/layout.html.twig

    Un layout est une structure de page, dans laquelle on peut ajouter des éléments/du contenu.
    Le concept des layout permet d'avoir plusieurs structures de pages dans notre site (ex: front vs backoffice).


2/ L'héritage Twig

    Avec Twig on parle d'héritage. Cela signifie que nos vues héritent (extends) d'un layout, et peuvent contenir de l'HTML à l'intérieur des block disponibles (crées dans le layout).


===> De manière générale, il faut voir le fonctionnement de Twig et de la méthode render comme un chargement du contenu de manière "empilée" (analogie de la poupée russe). Render temporise (mémoire tempon) le contenu, et affiche en même temps le layout, la vue et es params. 


3/ Modification de nos vues

    <code>
    {% extends 'layout.html.twig' %}
    {% block content %}
    Contenu HTML de la page
    {% endblock %}


    /!\ ATTENTION : Quand on utilise l'héritage Twig, nos vues ne peuvent contenir de l'HTML qu'à l'intérieur des blocks prévus pour.



4/ Documentation Twig 

    https://twig.symfony.com/doc/2.x/

====> A ce stade notre app permet d'afficher les pages accueil, inscription, connexion, profil, boutique, produit, categorie, gestion membre gestion produit, gestion commande.

====> Par contre nous ne sommes pas encore en mesure d'échanger avec la BDD (ajouter un contenu, et récupérer le contenu). Il faut voir les Entity et Doctrine.




-------------------------------------------
ETAPE 6 : Les assets
-------------------------------------------




-------------------------------------------
ETAPE 7 : Entités
-------------------------------------------
Sommaire : 
1/ Doctrine ORM et le concept des Entité (Entity)
2/ Créer Entité Produit
3/ Annotation
4/ Mettre à jour la BDD 
3/ Générer les entités en ligne de commande 
3/ Générer la BDD via les Entités 
3/ Générer les entités depuis la BDD 
-------------------------------------------

1/ Doctrine ORM et le concept des Entité (Entity)

    - D'une certaine manière, les entités correspondent à la partie MODEL de notre MVC. C'est la relation avec la BDD, mais en PHP et non en SQL.
    - Théoriquement, nous n'avons plus besoin du DQL.

    - ORM : Object Relation Mapping

    - Nous allons créer nos entités, sous forme de classes PHP (POPO : Plain Old PHP Object), qui vont permettre à Doctrine de comprendre notre BDD et de la manipuler.

    Par exemple : Pour faire INSERT INTO Produit 

    $produit = new Produit;
    persist($produit);

    supprimer produit
    remove($produit);

    Créer un formulaire
    createForm($produit);

===> Pour que tout cela soit possible il faut expliquer à Doctrine, quelle relation existe entre la BDD et nos Entity. 


2/ Créer Entité Produit

    A. Créer le dossier src/AppBundle/Entity/
    B. Créer le fichier src/AppBundle/Entity/Produit.php
    C. Créer notre class Produit  et nos propriétés et les Getters et les Setters


3/ Annotation
